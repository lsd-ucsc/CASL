---
header-includes: |
    \usepackage{amssymb}
    \usepackage{bussproofs}
    \usepackage{amsthm}
    \newtheorem*{remark}{Remark}
    \newtheorem{definition}{Definition}[section]
    \newtheorem{theorem}{Theorem}[section]
    \newtheorem{corollary}{Corollary}[theorem]
    \newtheorem{lemma}[theorem]{Lemma}
title: Process-local causal delivery
...

This document lays out what we mean by process-local causal delivery.

## System model

We model a distributed system as a finite set of $N$ nodes which communicate by
passing Messages over a asynchronous network. Nodes are identified by their
Process.

Nodes behave as though they are single threaded, and are comprised of
two components: a user application and a message passing algorithm.
The user application decides when to send messages, message content, and when
to read messages.
The message passing algorithm handles sending messages via the network on
behalf of the user application, receipt of messages from other nodes on the
network, and determining when received messages are delivered (made available
to be read by the user application).
We regard the operation of user applications as opaque and concern ourselves
with the behavior of the message passing algorithm.

\begin{definition}[Process]
Identifier for a node, which is comparable for equality, but otherwise opaque,
and is guaranteed to be unique for node participating in a distributed system.
\end{definition}

\begin{definition}[Message]
A container for message content generated by a user application, with metadata
determined by the message passing algorithm.
Comparable for equality but otherwise opaque to anything other than the message
passing algorithm.
\end{definition}

A distributed system can be said to incrementally construct an Execution as it
runs.
At each node the user application generates send Events, and the message
passing algorithm receives messages from the network and eventually generates
deliver Events.
If each participant node accumulates this sequence of Events in a
ProcessHistory, the oracle view which associates each history with its Process
is called an Execution.

\begin{definition}[Event]
Either $deliver_p(m)$ or $broadcast(m)$, indicating the Process where a Message
is delivered, or that a Message was sent. We are only concerned with broadcast
messages. A message passing algorithm may associate an event with metadata.
\end{definition}

\begin{definition}[ProcessHistory]
A sequence of Events which have occured at a Process over the course of running
a message passing algorithm.
\end{definition}

\begin{definition}[Execution]
A mapping from Process to ProcessHistory.
An oracle view of the global behavior of a message passing algorithm running on
several nodes.
\end{definition}

Given an Execution of a distributed system, the happens before relation is the
partial order including pairs of events which have a defined order.
The process order relation is a subset of the happens before relation.
The process order relation includes all pairs of Events occurring on the same
node and gives them a total order.

\begin{definition}[Process-order, \(\rightarrow_p\)]
\label{po}
Given events $e$ and $e'$ occurring in ProcessHistory $h_p$, write $e
\rightarrow_p e'$ to indicate $e$ appears in the subset/subsequence of $h_p$
prior to $e'$.
\end{definition}

\begin{definition}[Happens-before, \(\rightarrow\)]
\label{hb}
Given events $e$ and $e'$, write $e \rightarrow e'$ to indicate one of the following holds:
\begin{itemize}
\item $e$ and $e'$ both occur in the ProcessHistory $h_p$ for Process $p$, and
$e \rightarrow_p e'$ (Def. \ref{po}).
\item $e$ is a broadcast and $e'$ is a delivery of some Message $m$.
\item $e \rightarrow e^3$ and $e^3 \rightarrow e'$ for some Event $e^3$.
\end{itemize}
\end{definition}

We write $e \in h$ to indicate the Event $e$ is present in the ProcessHistory
$h$.

We write $x[p]$ to indicate the ProcessHistory associated with the Process $p$
in the Execution $x$. If there is no such Process in the Execution, it
indicates the empty ProcessHistory.

We may occasionally use a shorthand for Messages, $m_1 \rightarrow m_2$, to
relate the Events $\text{broadcast}(m_1) \rightarrow \text{broadcast}(m_2)$.

## Causal Delivery

$$
         \text{broadcast}(m) \rightarrow \text{broadcast}(m')
\implies \text{deliver}_p(m) \rightarrow_p \text{deliver}_p(m')
$$

Causal delivery is when Messages with a broadcast order are delivered in that
order at each node.
Causal delivery applies when all four of those Events are present in an
Execution, otherwise the definition doesn't apply.

\begin{definition}[Causal Delivery]
\label{cd}
$$\begin{aligned}
 \forall    \quad   x            &: \text{Execution}    ,
            \\      p, q, r      &: \text{Process}      ,
            \\      m, m'        &: \text{Message}      .
            \\  (                &          \text{broadcast}(m)  \in x[q]
            \\              \land&          \text{broadcast}(m') \in x[r]
            \\              \land&          \text{deliver}_p(m)  \in x[p]
            \\              \land&          \text{deliver}_p(m') \in x[p]
            \\              \land&          \text{broadcast}(m) \rightarrow \text{broadcast}(m')
                )                 \implies  \text{deliver}_p(m) \rightarrow_p \text{deliver}_p(m')
\end{aligned}$$
\end{definition}

### Vector Clock Isomorphism

$$
VC(e) < VC(e') \iff e \rightarrow e'
$$

The vector clock isomorphism says the less-than relation on vector clocks
associated with Events is isomorphic to the happens before relation
(Def. \ref{hb}) on those Events.^[TODO: define less-than on vector
clocks; define vector clocks]

\begin{definition}[Vector Clock Isomorphism]
$$\begin{aligned}
 \forall    \quad   x            &: \text{Execution}    ,
            \\      q, r         &: \text{Process}      ,
            \\      e, e'        &: \text{Event}        .
            \\                   &          e  \in x[q]
            \\              \land&          e' \in x[r]
            \\              \land&  (       VC(e) < VC(e')
                                  \iff e \rightarrow e'
                                    )
\end{aligned}$$
\end{definition}

\begin{remark}[Execution coupled to Vector Clocks]
The use of the happens before relation hints that the construction of vector
clocks by the message passing algorithm is important.
The isomorphism implies a strong coupling between the structure of the
Execution and the vector clocks associated with each Event.
\end{remark}

We write $VC(e)$ to indicate the vector clock associated with Event $e$, which
is metadata produced by some message passing algorithms.

We may occasionally use a shorthand for Messages, $VC(m)$, meaning
$VC(\text{broadcast}(m))$.

### Process-local Causal Delivery

Process-local causal delivery is when Messages with a broadcast order
(according to associated vector clocks) are delivered in that order by a node.
Whereas causal delivery (Def. \ref{cd}) reasons about four Events
present in an Execution, process-local causal delivery reasons separately about
each node and its ProcessHistory.

\begin{definition}[Process-local Causal Delivery]
\label{plcd}
$$\begin{aligned}
 \forall    \quad   h_p          &: \text{ProcessHistory}   ,
            \\      m, m'        &: \text{Message}          .
            \\  (                &          \text{deliver}_p(m)  \in h_p
            \\              \land&          \text{deliver}_p(m') \in h_p
            \\              \land&          VC(\text{broadcast}(m)) < VC(\text{broadcast}(m'))
                )                 \implies  \text{deliver}_p(m) \rightarrow_p \text{deliver}_p(m')
\end{aligned}$$
\end{definition}

The following distinguishes the definition of process-local causal delivery
from causal delivery (Def. \ref{cd}).

1. The execution $x$ and references to process histories $x[q]$ and $x[r]$ were
   removed. The process history $x[p]$ is replaced by $h_p$.
1. The broadcast order of the messages is attested to by the vc-less ordering
   of the messages' broadcast times.

## Theorems

CBCAST is a message passing algorithm about which we would like to prove some
properties.

\begin{lemma}[CBCAST observes Process-local Causal Delivery]
\label{cbcast-plcd}
Any node running CBCAST will produce a ProcessHistory which satisfies
process-local causal delivery (Def. \ref{plcd}).
\end{lemma}
[^cbcast-plcd-proof]

[^cbcast-plcd-proof]:
    Proof (todo):

    * Messages go into the delay queue.
    * Messages come out of the delay queue in VC-order
    * No messages are ever skipped.

\begin{lemma}[Process-local Causal Delivery implies Causal Delivery]
\label{plcd-cd}
If every node in an Execution observes Process-local Causal Delivery (Def.
\ref{plcd}), then the Execution observes Causal Delivery (Def. \ref{cd}).
\end{lemma}
[^plcd-cd-proof]

[^plcd-cd-proof]:
    Proof (todo):

    * Take the vector clock isomorphism as an axiom^[Thanks Gan and Simon!]

\begin{theorem}[CBCAST observes Causal Delivery]
\label{cbcast-cd}
If every node in an Execution is running CBCAST then the execution observes Causal Delivery (Def. \ref{cd}).
\end{theorem}
[^cbcast-cd-proof]

[^cbcast-cd-proof]:
    Proof (todo):

    * Lemma \ref{cbcast-plcd}
    * Lemma \ref{plcd-cd}

# Other things

Executions produced by CBCAST have the following additional properties,
probably:

* Messages are never delivered before they are sent.
* The Process $p$ on every Event $deliver_p(m)$ in a ProcessHistory $h_p$
  is the same $p$ which maps to $h_p$ from the Execution $x$ via $x[p]$.
* The Process $p$ mapping to a ProcessHistory $x[p]$ in the Execution $x$
  must be the Process on every $deliver_p(m)$ in that ProcessHistory.
* TODO: select one of the two above; they say the same thing differently.

Variable names should follow this convention:

* $x$, $y$, and $z$ are Executions.
* $p$, $q$, and $r$ are Processes.
* $m$, $m'$, $m_1$, and $m_2$ are Messages.
* $e$, $e'$, $e_1$, and $e_2$ are Events.
